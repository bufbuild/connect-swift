// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: grpc/testing/messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// This is copied from gRPC's testing Protobuf definitions: https://github.com/grpc/grpc/blob/master/src/proto/grpc/testing/messages.proto

// Copyright 2015-2016 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Message definitions to be used by integration test service definitions.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The type of payload that should be returned.
enum Grpc_Testing_PayloadType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Compressable text format.
  case compressable // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .compressable
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .compressable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .compressable: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grpc_Testing_PayloadType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_PayloadType] = [
    .compressable,
  ]
}

#endif  // swift(>=4.2)

/// The type of route that a client took to reach a server w.r.t. gRPCLB.
/// The server must fill in "fallback" if it detects that the RPC reached
/// the server via the "gRPCLB fallback" path, and "backend" if it detects
/// that the RPC reached the server via "gRPCLB backend" path (i.e. if it got
/// the address of this server from the gRPCLB server BalanceLoad RPC). Exactly
/// how this detection is done is context and server dependent.
enum Grpc_Testing_GrpclbRouteType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Server didn't detect the route that a client took to reach it.
  case unknown // = 0

  /// Indicates that a client reached a server via gRPCLB fallback.
  case fallback // = 1

  /// Indicates that a client reached a server as a gRPCLB-given backend.
  case backend // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .fallback
    case 2: self = .backend
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .fallback: return 1
    case .backend: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grpc_Testing_GrpclbRouteType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_GrpclbRouteType] = [
    .unknown,
    .fallback,
    .backend,
  ]
}

#endif  // swift(>=4.2)

/// A block of data, to simply increase gRPC message size.
struct Grpc_Testing_Payload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of data in body.
  var type: Grpc_Testing_PayloadType = .compressable

  /// Primary contents of payload.
  var body: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A protobuf representation for grpc status. This is used by test
/// clients to specify a status that the server should attempt to return.
struct Grpc_Testing_EchoStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 = 0

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Unary request.
struct Grpc_Testing_SimpleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Desired payload type in the response from the server.
  /// If response_type is RANDOM, server randomly chooses one from other formats.
  var responseType: Grpc_Testing_PayloadType = .compressable

  /// Desired payload size in the response from the server.
  var responseSize: Int32 = 0

  /// Optional input payload sent along with the request.
  var payload: Grpc_Testing_Payload {
    get {return _payload ?? Grpc_Testing_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  /// Whether SimpleResponse should include username.
  var fillUsername: Bool = false

  /// Whether SimpleResponse should include OAuth scope.
  var fillOauthScope: Bool = false

  /// Whether to request the server to compress the response. This field is
  /// "nullable" in order to interoperate seamlessly with clients not able to
  /// implement the full compression tests by introspecting the call to verify
  /// the response's compression status.
  var responseCompressed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _responseCompressed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_responseCompressed = newValue}
  }
  /// Returns true if `responseCompressed` has been explicitly set.
  var hasResponseCompressed: Bool {return self._responseCompressed != nil}
  /// Clears the value of `responseCompressed`. Subsequent reads from it will return its default value.
  mutating func clearResponseCompressed() {self._responseCompressed = nil}

  /// Whether server should return a given status
  var responseStatus: Grpc_Testing_EchoStatus {
    get {return _responseStatus ?? Grpc_Testing_EchoStatus()}
    set {_responseStatus = newValue}
  }
  /// Returns true if `responseStatus` has been explicitly set.
  var hasResponseStatus: Bool {return self._responseStatus != nil}
  /// Clears the value of `responseStatus`. Subsequent reads from it will return its default value.
  mutating func clearResponseStatus() {self._responseStatus = nil}

  /// Whether the server should expect this request to be compressed.
  var expectCompressed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _expectCompressed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_expectCompressed = newValue}
  }
  /// Returns true if `expectCompressed` has been explicitly set.
  var hasExpectCompressed: Bool {return self._expectCompressed != nil}
  /// Clears the value of `expectCompressed`. Subsequent reads from it will return its default value.
  mutating func clearExpectCompressed() {self._expectCompressed = nil}

  /// Whether SimpleResponse should include server_id.
  var fillServerID: Bool = false

  /// Whether SimpleResponse should include grpclb_route_type.
  var fillGrpclbRouteType: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Grpc_Testing_Payload? = nil
  fileprivate var _responseCompressed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _responseStatus: Grpc_Testing_EchoStatus? = nil
  fileprivate var _expectCompressed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Unary response, as configured by the request.
struct Grpc_Testing_SimpleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Payload to increase message size.
  var payload: Grpc_Testing_Payload {
    get {return _payload ?? Grpc_Testing_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  /// The user the request came from, for verifying authentication was
  /// successful when the client expected it.
  var username: String = String()

  /// OAuth scope.
  var oauthScope: String = String()

  /// Server ID. This must be unique among different server instances,
  /// but the same across all RPC's made to a particular server instance.
  var serverID: String = String()

  /// gRPCLB Path.
  var grpclbRouteType: Grpc_Testing_GrpclbRouteType = .unknown

  /// Server hostname.
  var hostname: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Grpc_Testing_Payload? = nil
}

/// Client-streaming request.
struct Grpc_Testing_StreamingInputCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional input payload sent along with the request.
  var payload: Grpc_Testing_Payload {
    get {return _payload ?? Grpc_Testing_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  /// Whether the server should expect this request to be compressed. This field
  /// is "nullable" in order to interoperate seamlessly with servers not able to
  /// implement the full compression tests by introspecting the call to verify
  /// the request's compression status.
  var expectCompressed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _expectCompressed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_expectCompressed = newValue}
  }
  /// Returns true if `expectCompressed` has been explicitly set.
  var hasExpectCompressed: Bool {return self._expectCompressed != nil}
  /// Clears the value of `expectCompressed`. Subsequent reads from it will return its default value.
  mutating func clearExpectCompressed() {self._expectCompressed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Grpc_Testing_Payload? = nil
  fileprivate var _expectCompressed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Client-streaming response.
struct Grpc_Testing_StreamingInputCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Aggregated size of payloads received from the client.
  var aggregatedPayloadSize: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configuration for a particular response.
struct Grpc_Testing_ResponseParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Desired payload sizes in responses from the server.
  var size: Int32 = 0

  /// Desired interval between consecutive responses in the response stream in
  /// microseconds.
  var intervalUs: Int32 = 0

  /// Whether to request the server to compress the response. This field is
  /// "nullable" in order to interoperate seamlessly with clients not able to
  /// implement the full compression tests by introspecting the call to verify
  /// the response's compression status.
  var compressed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _compressed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_compressed = newValue}
  }
  /// Returns true if `compressed` has been explicitly set.
  var hasCompressed: Bool {return self._compressed != nil}
  /// Clears the value of `compressed`. Subsequent reads from it will return its default value.
  mutating func clearCompressed() {self._compressed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _compressed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Server-streaming request.
struct Grpc_Testing_StreamingOutputCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Desired payload type in the response from the server.
  /// If response_type is RANDOM, the payload from each response in the stream
  /// might be of different types. This is to simulate a mixed type of payload
  /// stream.
  var responseType: Grpc_Testing_PayloadType = .compressable

  /// Configuration for each expected response message.
  var responseParameters: [Grpc_Testing_ResponseParameters] = []

  /// Optional input payload sent along with the request.
  var payload: Grpc_Testing_Payload {
    get {return _payload ?? Grpc_Testing_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  /// Whether server should return a given status
  var responseStatus: Grpc_Testing_EchoStatus {
    get {return _responseStatus ?? Grpc_Testing_EchoStatus()}
    set {_responseStatus = newValue}
  }
  /// Returns true if `responseStatus` has been explicitly set.
  var hasResponseStatus: Bool {return self._responseStatus != nil}
  /// Clears the value of `responseStatus`. Subsequent reads from it will return its default value.
  mutating func clearResponseStatus() {self._responseStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Grpc_Testing_Payload? = nil
  fileprivate var _responseStatus: Grpc_Testing_EchoStatus? = nil
}

/// Server-streaming response, as configured by the request and parameters.
struct Grpc_Testing_StreamingOutputCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Payload to increase response size.
  var payload: Grpc_Testing_Payload {
    get {return _payload ?? Grpc_Testing_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Grpc_Testing_Payload? = nil
}

/// For reconnect interop test only.
/// Client tells server what reconnection parameters it used.
struct Grpc_Testing_ReconnectParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxReconnectBackoffMs: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// For reconnect interop test only.
/// Server tells client whether its reconnects are following the spec and the
/// reconnect backoffs it saw.
struct Grpc_Testing_ReconnectInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var passed: Bool = false

  var backoffMs: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_LoadBalancerStatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request stats for the next num_rpcs sent by client.
  var numRpcs: Int32 = 0

  /// If num_rpcs have not completed within timeout_sec, return partial results.
  var timeoutSec: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_LoadBalancerStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of completed RPCs for each peer.
  var rpcsByPeer: Dictionary<String,Int32> = [:]

  /// The number of RPCs that failed to record a remote peer.
  var numFailures: Int32 = 0

  var rpcsByMethod: Dictionary<String,Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RpcsByPeer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of completed RPCs for each peer.
    var rpcsByPeer: Dictionary<String,Int32> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Request for retrieving a test client's accumulated stats.
struct Grpc_Testing_LoadBalancerAccumulatedStatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Accumulated stats for RPCs sent by a test client.
struct Grpc_Testing_LoadBalancerAccumulatedStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The total number of RPCs have ever issued for each type.
  /// Deprecated: use stats_per_method.rpcs_started instead.
  var numRpcsStartedByMethod: Dictionary<String,Int32> = [:]

  /// The total number of RPCs have ever completed successfully for each type.
  /// Deprecated: use stats_per_method.result instead.
  var numRpcsSucceededByMethod: Dictionary<String,Int32> = [:]

  /// The total number of RPCs have ever failed for each type.
  /// Deprecated: use stats_per_method.result instead.
  var numRpcsFailedByMethod: Dictionary<String,Int32> = [:]

  /// Per-method RPC statistics.  The key is the RpcType in string form; e.g.
  /// 'EMPTY_CALL' or 'UNARY_CALL'
  var statsPerMethod: Dictionary<String,Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct MethodStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of RPCs that were started for this method.
    var rpcsStarted: Int32 = 0

    /// The number of RPCs that completed with each status for this method.  The
    /// key is the integral value of a google.rpc.Code; the value is the count.
    var result: Dictionary<Int32,Int32> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Configurations for a test client.
struct Grpc_Testing_ClientConfigureRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The types of RPCs the client sends.
  var types: [Grpc_Testing_ClientConfigureRequest.RpcType] = []

  /// The collection of custom metadata to be attached to RPCs sent by the client.
  var metadata: [Grpc_Testing_ClientConfigureRequest.Metadata] = []

  /// The deadline to use, in seconds, for all RPCs.  If unset or zero, the
  /// client will use the default from the command-line.
  var timeoutSec: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of RPCs to send.
  enum RpcType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case emptyCall // = 0
    case unaryCall // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .emptyCall
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .emptyCall
      case 1: self = .unaryCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .emptyCall: return 0
      case .unaryCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Metadata to be attached for the given type of RPCs.
  struct Metadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Grpc_Testing_ClientConfigureRequest.RpcType = .emptyCall

    var key: String = String()

    var value: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Grpc_Testing_ClientConfigureRequest.RpcType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_ClientConfigureRequest.RpcType] = [
    .emptyCall,
    .unaryCall,
  ]
}

#endif  // swift(>=4.2)

/// Response for updating a test client's configuration.
struct Grpc_Testing_ClientConfigureResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_ErrorDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: String = String()

  var domain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_ErrorStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 = 0

  var message: String = String()

  var details: [SwiftProtobuf.Google_Protobuf_Any] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Grpc_Testing_PayloadType: @unchecked Sendable {}
extension Grpc_Testing_GrpclbRouteType: @unchecked Sendable {}
extension Grpc_Testing_Payload: @unchecked Sendable {}
extension Grpc_Testing_EchoStatus: @unchecked Sendable {}
extension Grpc_Testing_SimpleRequest: @unchecked Sendable {}
extension Grpc_Testing_SimpleResponse: @unchecked Sendable {}
extension Grpc_Testing_StreamingInputCallRequest: @unchecked Sendable {}
extension Grpc_Testing_StreamingInputCallResponse: @unchecked Sendable {}
extension Grpc_Testing_ResponseParameters: @unchecked Sendable {}
extension Grpc_Testing_StreamingOutputCallRequest: @unchecked Sendable {}
extension Grpc_Testing_StreamingOutputCallResponse: @unchecked Sendable {}
extension Grpc_Testing_ReconnectParams: @unchecked Sendable {}
extension Grpc_Testing_ReconnectInfo: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerStatsRequest: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerStatsResponse: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerAccumulatedStatsRequest: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerAccumulatedStatsResponse: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats: @unchecked Sendable {}
extension Grpc_Testing_ClientConfigureRequest: @unchecked Sendable {}
extension Grpc_Testing_ClientConfigureRequest.RpcType: @unchecked Sendable {}
extension Grpc_Testing_ClientConfigureRequest.Metadata: @unchecked Sendable {}
extension Grpc_Testing_ClientConfigureResponse: @unchecked Sendable {}
extension Grpc_Testing_ErrorDetail: @unchecked Sendable {}
extension Grpc_Testing_ErrorStatus: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grpc.testing"

extension Grpc_Testing_PayloadType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMPRESSABLE"),
  ]
}

extension Grpc_Testing_GrpclbRouteType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GRPCLB_ROUTE_TYPE_UNKNOWN"),
    1: .same(proto: "GRPCLB_ROUTE_TYPE_FALLBACK"),
    2: .same(proto: "GRPCLB_ROUTE_TYPE_BACKEND"),
  ]
}

extension Grpc_Testing_Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .compressable {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_Payload, rhs: Grpc_Testing_Payload) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_EchoStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EchoStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_EchoStatus, rhs: Grpc_Testing_EchoStatus) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_SimpleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimpleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_type"),
    2: .standard(proto: "response_size"),
    3: .same(proto: "payload"),
    4: .standard(proto: "fill_username"),
    5: .standard(proto: "fill_oauth_scope"),
    6: .standard(proto: "response_compressed"),
    7: .standard(proto: "response_status"),
    8: .standard(proto: "expect_compressed"),
    9: .standard(proto: "fill_server_id"),
    10: .standard(proto: "fill_grpclb_route_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.responseType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.responseSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.fillUsername) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.fillOauthScope) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._responseCompressed) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._responseStatus) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._expectCompressed) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.fillServerID) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.fillGrpclbRouteType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.responseType != .compressable {
      try visitor.visitSingularEnumField(value: self.responseType, fieldNumber: 1)
    }
    if self.responseSize != 0 {
      try visitor.visitSingularInt32Field(value: self.responseSize, fieldNumber: 2)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.fillUsername != false {
      try visitor.visitSingularBoolField(value: self.fillUsername, fieldNumber: 4)
    }
    if self.fillOauthScope != false {
      try visitor.visitSingularBoolField(value: self.fillOauthScope, fieldNumber: 5)
    }
    try { if let v = self._responseCompressed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._responseStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._expectCompressed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.fillServerID != false {
      try visitor.visitSingularBoolField(value: self.fillServerID, fieldNumber: 9)
    }
    if self.fillGrpclbRouteType != false {
      try visitor.visitSingularBoolField(value: self.fillGrpclbRouteType, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_SimpleRequest, rhs: Grpc_Testing_SimpleRequest) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.responseSize != rhs.responseSize {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.fillUsername != rhs.fillUsername {return false}
    if lhs.fillOauthScope != rhs.fillOauthScope {return false}
    if lhs._responseCompressed != rhs._responseCompressed {return false}
    if lhs._responseStatus != rhs._responseStatus {return false}
    if lhs._expectCompressed != rhs._expectCompressed {return false}
    if lhs.fillServerID != rhs.fillServerID {return false}
    if lhs.fillGrpclbRouteType != rhs.fillGrpclbRouteType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_SimpleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimpleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "username"),
    3: .standard(proto: "oauth_scope"),
    4: .standard(proto: "server_id"),
    5: .standard(proto: "grpclb_route_type"),
    6: .same(proto: "hostname"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.oauthScope) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serverID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.grpclbRouteType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.oauthScope.isEmpty {
      try visitor.visitSingularStringField(value: self.oauthScope, fieldNumber: 3)
    }
    if !self.serverID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverID, fieldNumber: 4)
    }
    if self.grpclbRouteType != .unknown {
      try visitor.visitSingularEnumField(value: self.grpclbRouteType, fieldNumber: 5)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_SimpleResponse, rhs: Grpc_Testing_SimpleResponse) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.username != rhs.username {return false}
    if lhs.oauthScope != rhs.oauthScope {return false}
    if lhs.serverID != rhs.serverID {return false}
    if lhs.grpclbRouteType != rhs.grpclbRouteType {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_StreamingInputCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingInputCallRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .standard(proto: "expect_compressed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expectCompressed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expectCompressed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_StreamingInputCallRequest, rhs: Grpc_Testing_StreamingInputCallRequest) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs._expectCompressed != rhs._expectCompressed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_StreamingInputCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingInputCallResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aggregated_payload_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.aggregatedPayloadSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.aggregatedPayloadSize != 0 {
      try visitor.visitSingularInt32Field(value: self.aggregatedPayloadSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_StreamingInputCallResponse, rhs: Grpc_Testing_StreamingInputCallResponse) -> Bool {
    if lhs.aggregatedPayloadSize != rhs.aggregatedPayloadSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ResponseParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .standard(proto: "interval_us"),
    3: .same(proto: "compressed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.intervalUs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._compressed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.intervalUs != 0 {
      try visitor.visitSingularInt32Field(value: self.intervalUs, fieldNumber: 2)
    }
    try { if let v = self._compressed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ResponseParameters, rhs: Grpc_Testing_ResponseParameters) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.intervalUs != rhs.intervalUs {return false}
    if lhs._compressed != rhs._compressed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_StreamingOutputCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingOutputCallRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_type"),
    2: .standard(proto: "response_parameters"),
    3: .same(proto: "payload"),
    7: .standard(proto: "response_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.responseType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.responseParameters) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._responseStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.responseType != .compressable {
      try visitor.visitSingularEnumField(value: self.responseType, fieldNumber: 1)
    }
    if !self.responseParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseParameters, fieldNumber: 2)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._responseStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_StreamingOutputCallRequest, rhs: Grpc_Testing_StreamingOutputCallRequest) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.responseParameters != rhs.responseParameters {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs._responseStatus != rhs._responseStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_StreamingOutputCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingOutputCallResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_StreamingOutputCallResponse, rhs: Grpc_Testing_StreamingOutputCallResponse) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ReconnectParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReconnectParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_reconnect_backoff_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.maxReconnectBackoffMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxReconnectBackoffMs != 0 {
      try visitor.visitSingularInt32Field(value: self.maxReconnectBackoffMs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ReconnectParams, rhs: Grpc_Testing_ReconnectParams) -> Bool {
    if lhs.maxReconnectBackoffMs != rhs.maxReconnectBackoffMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ReconnectInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReconnectInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "passed"),
    2: .standard(proto: "backoff_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.passed) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.backoffMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.passed != false {
      try visitor.visitSingularBoolField(value: self.passed, fieldNumber: 1)
    }
    if !self.backoffMs.isEmpty {
      try visitor.visitPackedInt32Field(value: self.backoffMs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ReconnectInfo, rhs: Grpc_Testing_ReconnectInfo) -> Bool {
    if lhs.passed != rhs.passed {return false}
    if lhs.backoffMs != rhs.backoffMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancerStatsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_rpcs"),
    2: .standard(proto: "timeout_sec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numRpcs) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.timeoutSec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numRpcs != 0 {
      try visitor.visitSingularInt32Field(value: self.numRpcs, fieldNumber: 1)
    }
    if self.timeoutSec != 0 {
      try visitor.visitSingularInt32Field(value: self.timeoutSec, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerStatsRequest, rhs: Grpc_Testing_LoadBalancerStatsRequest) -> Bool {
    if lhs.numRpcs != rhs.numRpcs {return false}
    if lhs.timeoutSec != rhs.timeoutSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancerStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rpcs_by_peer"),
    2: .standard(proto: "num_failures"),
    3: .standard(proto: "rpcs_by_method"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.rpcsByPeer) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numFailures) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer>.self, value: &self.rpcsByMethod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rpcsByPeer.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.rpcsByPeer, fieldNumber: 1)
    }
    if self.numFailures != 0 {
      try visitor.visitSingularInt32Field(value: self.numFailures, fieldNumber: 2)
    }
    if !self.rpcsByMethod.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer>.self, value: self.rpcsByMethod, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerStatsResponse, rhs: Grpc_Testing_LoadBalancerStatsResponse) -> Bool {
    if lhs.rpcsByPeer != rhs.rpcsByPeer {return false}
    if lhs.numFailures != rhs.numFailures {return false}
    if lhs.rpcsByMethod != rhs.rpcsByMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_Testing_LoadBalancerStatsResponse.protoMessageName + ".RpcsByPeer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rpcs_by_peer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.rpcsByPeer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rpcsByPeer.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.rpcsByPeer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer, rhs: Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer) -> Bool {
    if lhs.rpcsByPeer != rhs.rpcsByPeer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerAccumulatedStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancerAccumulatedStatsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerAccumulatedStatsRequest, rhs: Grpc_Testing_LoadBalancerAccumulatedStatsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerAccumulatedStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancerAccumulatedStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_rpcs_started_by_method"),
    2: .standard(proto: "num_rpcs_succeeded_by_method"),
    3: .standard(proto: "num_rpcs_failed_by_method"),
    4: .standard(proto: "stats_per_method"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.numRpcsStartedByMethod) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.numRpcsSucceededByMethod) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.numRpcsFailedByMethod) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats>.self, value: &self.statsPerMethod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.numRpcsStartedByMethod.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.numRpcsStartedByMethod, fieldNumber: 1)
    }
    if !self.numRpcsSucceededByMethod.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.numRpcsSucceededByMethod, fieldNumber: 2)
    }
    if !self.numRpcsFailedByMethod.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.numRpcsFailedByMethod, fieldNumber: 3)
    }
    if !self.statsPerMethod.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats>.self, value: self.statsPerMethod, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerAccumulatedStatsResponse, rhs: Grpc_Testing_LoadBalancerAccumulatedStatsResponse) -> Bool {
    if lhs.numRpcsStartedByMethod != rhs.numRpcsStartedByMethod {return false}
    if lhs.numRpcsSucceededByMethod != rhs.numRpcsSucceededByMethod {return false}
    if lhs.numRpcsFailedByMethod != rhs.numRpcsFailedByMethod {return false}
    if lhs.statsPerMethod != rhs.statsPerMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_Testing_LoadBalancerAccumulatedStatsResponse.protoMessageName + ".MethodStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rpcs_started"),
    2: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rpcsStarted) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rpcsStarted != 0 {
      try visitor.visitSingularInt32Field(value: self.rpcsStarted, fieldNumber: 1)
    }
    if !self.result.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: self.result, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats, rhs: Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats) -> Bool {
    if lhs.rpcsStarted != rhs.rpcsStarted {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ClientConfigureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientConfigureRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "types"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "timeout_sec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.types) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.timeoutSec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.types.isEmpty {
      try visitor.visitPackedEnumField(value: self.types, fieldNumber: 1)
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 2)
    }
    if self.timeoutSec != 0 {
      try visitor.visitSingularInt32Field(value: self.timeoutSec, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ClientConfigureRequest, rhs: Grpc_Testing_ClientConfigureRequest) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.timeoutSec != rhs.timeoutSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ClientConfigureRequest.RpcType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMPTY_CALL"),
    1: .same(proto: "UNARY_CALL"),
  ]
}

extension Grpc_Testing_ClientConfigureRequest.Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_Testing_ClientConfigureRequest.protoMessageName + ".Metadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .emptyCall {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ClientConfigureRequest.Metadata, rhs: Grpc_Testing_ClientConfigureRequest.Metadata) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ClientConfigureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientConfigureResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ClientConfigureResponse, rhs: Grpc_Testing_ClientConfigureResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ErrorDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ErrorDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ErrorDetail, rhs: Grpc_Testing_ErrorDetail) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ErrorStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ErrorStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ErrorStatus, rhs: Grpc_Testing_ErrorStatus) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
