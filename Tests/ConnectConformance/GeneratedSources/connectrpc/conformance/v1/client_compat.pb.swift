// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: connectrpc/conformance/v1/client_compat.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023 The Connect Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes one call the client should make. The client reads
/// these from stdin and, for each one, invokes an RPC as directed
/// and writes the results (in the form of a ClientCompatResponse
/// message) to stdout.
struct Connectrpc_Conformance_V1_ClientCompatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var testName: String {
    get {return _storage._testName}
    set {_uniqueStorage()._testName = newValue}
  }

  var httpVersion: Connectrpc_Conformance_V1_HTTPVersion {
    get {return _storage._httpVersion}
    set {_uniqueStorage()._httpVersion = newValue}
  }

  var `protocol`: Connectrpc_Conformance_V1_Protocol {
    get {return _storage._protocol}
    set {_uniqueStorage()._protocol = newValue}
  }

  var codec: Connectrpc_Conformance_V1_Codec {
    get {return _storage._codec}
    set {_uniqueStorage()._codec = newValue}
  }

  var compression: Connectrpc_Conformance_V1_Compression {
    get {return _storage._compression}
    set {_uniqueStorage()._compression = newValue}
  }

  var host: String {
    get {return _storage._host}
    set {_uniqueStorage()._host = newValue}
  }

  var port: UInt32 {
    get {return _storage._port}
    set {_uniqueStorage()._port = newValue}
  }

  /// If non-empty, the server is using TLS. The bytes are the
  /// server's PEM-encoded certificate, which the client should
  /// verify and trust.
  var serverTlsCert: Data {
    get {return _storage._serverTlsCert}
    set {_uniqueStorage()._serverTlsCert = newValue}
  }

  /// If present, the client certificate credentials to use to
  /// authenticate with the server. This will only be present
  /// when server_tls_cert is non-empty.
  var clientTlsCreds: Connectrpc_Conformance_V1_ClientCompatRequest.TLSCreds {
    get {return _storage._clientTlsCreds ?? Connectrpc_Conformance_V1_ClientCompatRequest.TLSCreds()}
    set {_uniqueStorage()._clientTlsCreds = newValue}
  }
  /// Returns true if `clientTlsCreds` has been explicitly set.
  var hasClientTlsCreds: Bool {return _storage._clientTlsCreds != nil}
  /// Clears the value of `clientTlsCreds`. Subsequent reads from it will return its default value.
  mutating func clearClientTlsCreds() {_uniqueStorage()._clientTlsCreds = nil}

  /// If non-zero, indicates the maximum size in bytes for a message.
  /// If the server sends anything larger, the client should reject it.
  var messageReceiveLimit: UInt32 {
    get {return _storage._messageReceiveLimit}
    set {_uniqueStorage()._messageReceiveLimit = newValue}
  }

  var service: String {
    get {return _storage._service}
    set {_uniqueStorage()._service = newValue}
  }

  var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  var streamType: Connectrpc_Conformance_V1_StreamType {
    get {return _storage._streamType}
    set {_uniqueStorage()._streamType = newValue}
  }

  /// If protocol indicates Connect and stream type indicates
  /// Unary, this instructs the client to use a GET HTTP method
  /// when making the request.
  var useGetHTTPMethod: Bool {
    get {return _storage._useGetHTTPMethod}
    set {_uniqueStorage()._useGetHTTPMethod = newValue}
  }

  var requestHeaders: [Connectrpc_Conformance_V1_Header] {
    get {return _storage._requestHeaders}
    set {_uniqueStorage()._requestHeaders = newValue}
  }

  /// There will be exactly one for unary and server-stream methods.
  /// For client- and bidi-stream methods, all entries will have the
  /// same type URL (which matches the request type of the method).
  var requestMessages: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._requestMessages}
    set {_uniqueStorage()._requestMessages = newValue}
  }

  var timeoutMs: UInt32 {
    get {return _storage._timeoutMs ?? 0}
    set {_uniqueStorage()._timeoutMs = newValue}
  }
  /// Returns true if `timeoutMs` has been explicitly set.
  var hasTimeoutMs: Bool {return _storage._timeoutMs != nil}
  /// Clears the value of `timeoutMs`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutMs() {_uniqueStorage()._timeoutMs = nil}

  /// Wait this many milliseconds before sending a request message.
  /// For client- or bidi-streaming requests, this delay should be
  /// applied before each request sent.
  var requestDelayMs: UInt32 {
    get {return _storage._requestDelayMs}
    set {_uniqueStorage()._requestDelayMs = newValue}
  }

  /// If present, the client should cancel the RPC instead of
  /// allowing to complete normally.
  var cancel: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel {
    get {return _storage._cancel ?? Connectrpc_Conformance_V1_ClientCompatRequest.Cancel()}
    set {_uniqueStorage()._cancel = newValue}
  }
  /// Returns true if `cancel` has been explicitly set.
  var hasCancel: Bool {return _storage._cancel != nil}
  /// Clears the value of `cancel`. Subsequent reads from it will return its default value.
  mutating func clearCancel() {_uniqueStorage()._cancel = nil}

  /// The following field is only used by the reference client. If
  /// you are implementing a client under test, you may ignore it
  /// or respond with an error if the client receives a request where
  /// it is set.
  ///
  /// When this field is present, it defines the actual HTTP request
  /// that will be sent. The above group of fields must still be
  /// provided and valid so that the reference client knows how it
  /// should try to interpret the server's response.
  var rawRequest: Connectrpc_Conformance_V1_RawHTTPRequest {
    get {return _storage._rawRequest ?? Connectrpc_Conformance_V1_RawHTTPRequest()}
    set {_uniqueStorage()._rawRequest = newValue}
  }
  /// Returns true if `rawRequest` has been explicitly set.
  var hasRawRequest: Bool {return _storage._rawRequest != nil}
  /// Clears the value of `rawRequest`. Subsequent reads from it will return its default value.
  mutating func clearRawRequest() {_uniqueStorage()._rawRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TLSCreds {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var cert: Data = Data()

    var key: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Cancel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// These fields determine the timing of cancellation.
    /// If none are present, the client should cancel immediately
    /// after all request messages are sent and the send side is
    /// closed (as if the after_close_send_ms field were present
    /// and zero).
    var cancelTiming: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel.OneOf_CancelTiming? = nil

    /// When present, the client should cancel *instead of*
    /// closing the send side of the stream, after all requests
    /// have been sent. This applies only to client and bidi
    /// stream RPCs.
    var beforeCloseSend: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .beforeCloseSend(let v)? = cancelTiming {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {cancelTiming = .beforeCloseSend(newValue)}
    }

    /// When present, the client should delay for this many
    /// milliseconds after closing the send side of the stream
    /// and then cancel.
    var afterCloseSendMs: UInt32 {
      get {
        if case .afterCloseSendMs(let v)? = cancelTiming {return v}
        return 0
      }
      set {cancelTiming = .afterCloseSendMs(newValue)}
    }

    /// When present, the client should cancel right after
    /// reading this number of response messages from the stream.
    /// This applies only to server and bidi stream RPCs.
    var afterNumResponses: UInt32 {
      get {
        if case .afterNumResponses(let v)? = cancelTiming {return v}
        return 0
      }
      set {cancelTiming = .afterNumResponses(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// These fields determine the timing of cancellation.
    /// If none are present, the client should cancel immediately
    /// after all request messages are sent and the send side is
    /// closed (as if the after_close_send_ms field were present
    /// and zero).
    enum OneOf_CancelTiming: Equatable {
      /// When present, the client should cancel *instead of*
      /// closing the send side of the stream, after all requests
      /// have been sent. This applies only to client and bidi
      /// stream RPCs.
      case beforeCloseSend(SwiftProtobuf.Google_Protobuf_Empty)
      /// When present, the client should delay for this many
      /// milliseconds after closing the send side of the stream
      /// and then cancel.
      case afterCloseSendMs(UInt32)
      /// When present, the client should cancel right after
      /// reading this number of response messages from the stream.
      /// This applies only to server and bidi stream RPCs.
      case afterNumResponses(UInt32)

    #if !swift(>=4.1)
      static func ==(lhs: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel.OneOf_CancelTiming, rhs: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel.OneOf_CancelTiming) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.beforeCloseSend, .beforeCloseSend): return {
          guard case .beforeCloseSend(let l) = lhs, case .beforeCloseSend(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.afterCloseSendMs, .afterCloseSendMs): return {
          guard case .afterCloseSendMs(let l) = lhs, case .afterCloseSendMs(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.afterNumResponses, .afterNumResponses): return {
          guard case .afterNumResponses(let l) = lhs, case .afterNumResponses(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The outcome of one ClientCompatRequest.
struct Connectrpc_Conformance_V1_ClientCompatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var testName: String = String()

  var result: Connectrpc_Conformance_V1_ClientCompatResponse.OneOf_Result? = nil

  var response: Connectrpc_Conformance_V1_ClientResponseResult {
    get {
      if case .response(let v)? = result {return v}
      return Connectrpc_Conformance_V1_ClientResponseResult()
    }
    set {result = .response(newValue)}
  }

  var error: Connectrpc_Conformance_V1_ClientErrorResult {
    get {
      if case .error(let v)? = result {return v}
      return Connectrpc_Conformance_V1_ClientErrorResult()
    }
    set {result = .error(newValue)}
  }

  /// This field is used only by the reference client, and it can be used
  /// to provide additional feedback about problems observed in the server
  /// response. If non-empty, the test case is considered failed even if
  /// the result above matches all expectations.
  var feedback: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable {
    case response(Connectrpc_Conformance_V1_ClientResponseResult)
    case error(Connectrpc_Conformance_V1_ClientErrorResult)

  #if !swift(>=4.1)
    static func ==(lhs: Connectrpc_Conformance_V1_ClientCompatResponse.OneOf_Result, rhs: Connectrpc_Conformance_V1_ClientCompatResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.response, .response): return {
        guard case .response(let l) = lhs, case .response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// The result of a ClientCompatRequest, which may or may not be successful.
struct Connectrpc_Conformance_V1_ClientResponseResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var responseHeaders: [Connectrpc_Conformance_V1_Header] = []

  var payloads: [Connectrpc_Conformance_V1_ConformancePayload] = []

  /// The error received from the actual RPC invocation. Note this is not representative
  /// of a runtime error and should always be the proto equivalent of a Connect error.
  var error: Connectrpc_Conformance_V1_Error {
    get {return _error ?? Connectrpc_Conformance_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var responseTrailers: [Connectrpc_Conformance_V1_Header] = []

  /// The number of messages that were present in the request but that could not be
  /// sent because an error occurred before finishing the upload.
  var numUnsentRequests: Int32 = 0

  /// The HTTP status code of the response.
  var actualStatusCode: Int32 = 0

  /// When processing an error from a Connect server, this should contain
  /// the actual JSON received on the wire.
  var connectErrorRaw: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _connectErrorRaw ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_connectErrorRaw = newValue}
  }
  /// Returns true if `connectErrorRaw` has been explicitly set.
  var hasConnectErrorRaw: Bool {return self._connectErrorRaw != nil}
  /// Clears the value of `connectErrorRaw`. Subsequent reads from it will return its default value.
  mutating func clearConnectErrorRaw() {self._connectErrorRaw = nil}

  /// Any HTTP trailers observed after the response body. These do NOT
  /// include trailers that conveyed via the body, as done in the gRPC-Web
  /// and Connect streaming protocols.
  var actualHTTPTrailers: [Connectrpc_Conformance_V1_Header] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Connectrpc_Conformance_V1_Error? = nil
  fileprivate var _connectErrorRaw: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// The client is not able to fulfill the ClientCompatRequest. This may be due
/// to a runtime error or an unexpected internal error such as the requested protocol
/// not being supported. This is completely independent of the actual RPC invocation.
struct Connectrpc_Conformance_V1_ClientErrorResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Connectrpc_Conformance_V1_ClientCompatRequest: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ClientCompatRequest.TLSCreds: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ClientCompatRequest.Cancel: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ClientCompatRequest.Cancel.OneOf_CancelTiming: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ClientCompatResponse: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ClientCompatResponse.OneOf_Result: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ClientResponseResult: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ClientErrorResult: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "connectrpc.conformance.v1"

extension Connectrpc_Conformance_V1_ClientCompatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientCompatRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_name"),
    2: .standard(proto: "http_version"),
    3: .same(proto: "protocol"),
    4: .same(proto: "codec"),
    5: .same(proto: "compression"),
    6: .same(proto: "host"),
    7: .same(proto: "port"),
    8: .standard(proto: "server_tls_cert"),
    9: .standard(proto: "client_tls_creds"),
    10: .standard(proto: "message_receive_limit"),
    11: .same(proto: "service"),
    12: .same(proto: "method"),
    13: .standard(proto: "stream_type"),
    14: .standard(proto: "use_get_http_method"),
    15: .standard(proto: "request_headers"),
    16: .standard(proto: "request_messages"),
    17: .standard(proto: "timeout_ms"),
    18: .standard(proto: "request_delay_ms"),
    19: .same(proto: "cancel"),
    20: .standard(proto: "raw_request"),
  ]

  fileprivate class _StorageClass {
    var _testName: String = String()
    var _httpVersion: Connectrpc_Conformance_V1_HTTPVersion = .unspecified
    var _protocol: Connectrpc_Conformance_V1_Protocol = .unspecified
    var _codec: Connectrpc_Conformance_V1_Codec = .unspecified
    var _compression: Connectrpc_Conformance_V1_Compression = .unspecified
    var _host: String = String()
    var _port: UInt32 = 0
    var _serverTlsCert: Data = Data()
    var _clientTlsCreds: Connectrpc_Conformance_V1_ClientCompatRequest.TLSCreds? = nil
    var _messageReceiveLimit: UInt32 = 0
    var _service: String = String()
    var _method: String = String()
    var _streamType: Connectrpc_Conformance_V1_StreamType = .unspecified
    var _useGetHTTPMethod: Bool = false
    var _requestHeaders: [Connectrpc_Conformance_V1_Header] = []
    var _requestMessages: [SwiftProtobuf.Google_Protobuf_Any] = []
    var _timeoutMs: UInt32? = nil
    var _requestDelayMs: UInt32 = 0
    var _cancel: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel? = nil
    var _rawRequest: Connectrpc_Conformance_V1_RawHTTPRequest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _testName = source._testName
      _httpVersion = source._httpVersion
      _protocol = source._protocol
      _codec = source._codec
      _compression = source._compression
      _host = source._host
      _port = source._port
      _serverTlsCert = source._serverTlsCert
      _clientTlsCreds = source._clientTlsCreds
      _messageReceiveLimit = source._messageReceiveLimit
      _service = source._service
      _method = source._method
      _streamType = source._streamType
      _useGetHTTPMethod = source._useGetHTTPMethod
      _requestHeaders = source._requestHeaders
      _requestMessages = source._requestMessages
      _timeoutMs = source._timeoutMs
      _requestDelayMs = source._requestDelayMs
      _cancel = source._cancel
      _rawRequest = source._rawRequest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._testName) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._httpVersion) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._protocol) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._codec) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._compression) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._host) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._port) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._serverTlsCert) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._clientTlsCreds) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._messageReceiveLimit) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._service) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._streamType) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._useGetHTTPMethod) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestHeaders) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestMessages) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._timeoutMs) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._requestDelayMs) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._cancel) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._rawRequest) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._testName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._testName, fieldNumber: 1)
      }
      if _storage._httpVersion != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._httpVersion, fieldNumber: 2)
      }
      if _storage._protocol != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._protocol, fieldNumber: 3)
      }
      if _storage._codec != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._codec, fieldNumber: 4)
      }
      if _storage._compression != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._compression, fieldNumber: 5)
      }
      if !_storage._host.isEmpty {
        try visitor.visitSingularStringField(value: _storage._host, fieldNumber: 6)
      }
      if _storage._port != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._port, fieldNumber: 7)
      }
      if !_storage._serverTlsCert.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._serverTlsCert, fieldNumber: 8)
      }
      try { if let v = _storage._clientTlsCreds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._messageReceiveLimit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._messageReceiveLimit, fieldNumber: 10)
      }
      if !_storage._service.isEmpty {
        try visitor.visitSingularStringField(value: _storage._service, fieldNumber: 11)
      }
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 12)
      }
      if _storage._streamType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._streamType, fieldNumber: 13)
      }
      if _storage._useGetHTTPMethod != false {
        try visitor.visitSingularBoolField(value: _storage._useGetHTTPMethod, fieldNumber: 14)
      }
      if !_storage._requestHeaders.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestHeaders, fieldNumber: 15)
      }
      if !_storage._requestMessages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestMessages, fieldNumber: 16)
      }
      try { if let v = _storage._timeoutMs {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 17)
      } }()
      if _storage._requestDelayMs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._requestDelayMs, fieldNumber: 18)
      }
      try { if let v = _storage._cancel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._rawRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientCompatRequest, rhs: Connectrpc_Conformance_V1_ClientCompatRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._testName != rhs_storage._testName {return false}
        if _storage._httpVersion != rhs_storage._httpVersion {return false}
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._codec != rhs_storage._codec {return false}
        if _storage._compression != rhs_storage._compression {return false}
        if _storage._host != rhs_storage._host {return false}
        if _storage._port != rhs_storage._port {return false}
        if _storage._serverTlsCert != rhs_storage._serverTlsCert {return false}
        if _storage._clientTlsCreds != rhs_storage._clientTlsCreds {return false}
        if _storage._messageReceiveLimit != rhs_storage._messageReceiveLimit {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._streamType != rhs_storage._streamType {return false}
        if _storage._useGetHTTPMethod != rhs_storage._useGetHTTPMethod {return false}
        if _storage._requestHeaders != rhs_storage._requestHeaders {return false}
        if _storage._requestMessages != rhs_storage._requestMessages {return false}
        if _storage._timeoutMs != rhs_storage._timeoutMs {return false}
        if _storage._requestDelayMs != rhs_storage._requestDelayMs {return false}
        if _storage._cancel != rhs_storage._cancel {return false}
        if _storage._rawRequest != rhs_storage._rawRequest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientCompatRequest.TLSCreds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Connectrpc_Conformance_V1_ClientCompatRequest.protoMessageName + ".TLSCreds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cert"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cert) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cert.isEmpty {
      try visitor.visitSingularBytesField(value: self.cert, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientCompatRequest.TLSCreds, rhs: Connectrpc_Conformance_V1_ClientCompatRequest.TLSCreds) -> Bool {
    if lhs.cert != rhs.cert {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientCompatRequest.Cancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Connectrpc_Conformance_V1_ClientCompatRequest.protoMessageName + ".Cancel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "before_close_send"),
    2: .standard(proto: "after_close_send_ms"),
    3: .standard(proto: "after_num_responses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.cancelTiming {
          hadOneofValue = true
          if case .beforeCloseSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cancelTiming = .beforeCloseSend(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.cancelTiming != nil {try decoder.handleConflictingOneOf()}
          self.cancelTiming = .afterCloseSendMs(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.cancelTiming != nil {try decoder.handleConflictingOneOf()}
          self.cancelTiming = .afterNumResponses(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.cancelTiming {
    case .beforeCloseSend?: try {
      guard case .beforeCloseSend(let v)? = self.cancelTiming else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .afterCloseSendMs?: try {
      guard case .afterCloseSendMs(let v)? = self.cancelTiming else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case .afterNumResponses?: try {
      guard case .afterNumResponses(let v)? = self.cancelTiming else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel, rhs: Connectrpc_Conformance_V1_ClientCompatRequest.Cancel) -> Bool {
    if lhs.cancelTiming != rhs.cancelTiming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientCompatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientCompatResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_name"),
    2: .same(proto: "response"),
    3: .same(proto: "error"),
    4: .same(proto: "feedback"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.testName) }()
      case 2: try {
        var v: Connectrpc_Conformance_V1_ClientResponseResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .response(v)
        }
      }()
      case 3: try {
        var v: Connectrpc_Conformance_V1_ClientErrorResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.feedback) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.testName.isEmpty {
      try visitor.visitSingularStringField(value: self.testName, fieldNumber: 1)
    }
    switch self.result {
    case .response?: try {
      guard case .response(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.feedback.isEmpty {
      try visitor.visitRepeatedStringField(value: self.feedback, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientCompatResponse, rhs: Connectrpc_Conformance_V1_ClientCompatResponse) -> Bool {
    if lhs.testName != rhs.testName {return false}
    if lhs.result != rhs.result {return false}
    if lhs.feedback != rhs.feedback {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientResponseResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientResponseResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_headers"),
    2: .same(proto: "payloads"),
    3: .same(proto: "error"),
    4: .standard(proto: "response_trailers"),
    5: .standard(proto: "num_unsent_requests"),
    6: .standard(proto: "actual_status_code"),
    7: .standard(proto: "connect_error_raw"),
    8: .standard(proto: "actual_http_trailers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responseHeaders) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.payloads) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.responseTrailers) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.numUnsentRequests) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.actualStatusCode) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._connectErrorRaw) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.actualHTTPTrailers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.responseHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseHeaders, fieldNumber: 1)
    }
    if !self.payloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payloads, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.responseTrailers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseTrailers, fieldNumber: 4)
    }
    if self.numUnsentRequests != 0 {
      try visitor.visitSingularInt32Field(value: self.numUnsentRequests, fieldNumber: 5)
    }
    if self.actualStatusCode != 0 {
      try visitor.visitSingularInt32Field(value: self.actualStatusCode, fieldNumber: 6)
    }
    try { if let v = self._connectErrorRaw {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.actualHTTPTrailers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actualHTTPTrailers, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientResponseResult, rhs: Connectrpc_Conformance_V1_ClientResponseResult) -> Bool {
    if lhs.responseHeaders != rhs.responseHeaders {return false}
    if lhs.payloads != rhs.payloads {return false}
    if lhs._error != rhs._error {return false}
    if lhs.responseTrailers != rhs.responseTrailers {return false}
    if lhs.numUnsentRequests != rhs.numUnsentRequests {return false}
    if lhs.actualStatusCode != rhs.actualStatusCode {return false}
    if lhs._connectErrorRaw != rhs._connectErrorRaw {return false}
    if lhs.actualHTTPTrailers != rhs.actualHTTPTrailers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientErrorResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientErrorResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientErrorResult, rhs: Connectrpc_Conformance_V1_ClientErrorResult) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
