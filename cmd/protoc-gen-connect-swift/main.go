package main

import (
	"fmt"
	"google.golang.org/protobuf/reflect/protoreflect"
	"os"
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const extension = ".swift"

func main() {
	protogen.Options{}.Run(
		func(plugin *protogen.Plugin) error {
			plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
			for _, file := range plugin.Files {
				if file.Generate {
					generate(plugin, file)
				}
			}
			return nil
		},
	)
}

func generate(plugin *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	output := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+extension, "")
	generatePreamble(output, file)
	generateImports(output)
	for _, service := range file.Services {
		generateServiceInterface(output, file, service)
		output.P()
		generateServiceImplementation(output, file, service)
	}
}

func generatePreamble(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by ", filepath.Base(os.Args[0]), ". DO NOT EDIT.")
	g.P("//")
	g.P("// Source: ", file.Desc.Path())
	g.P()
}

func generateImports(g *protogen.GeneratedFile) {
	g.P("import Connect")
	g.P("import Foundation")
	g.P()
}

func generateServiceInterface(g *protogen.GeneratedFile, file *protogen.File, service *protogen.Service) {
	serviceComments := strings.TrimSpace(service.Comments.Leading.String())
	if len(serviceComments) > 0 {
		g.P(serviceComments)
	}
	g.P("public protocol ", interfaceName(service), " {")

	for _, method := range service.Methods {
		g.P()
		for _, line := range strings.Split(strings.TrimSpace(method.Comments.Leading.String()), "\n") {
			g.P("\t", line)
		}
		g.P("\t", methodSignature(method, file, false))
	}

	g.P("}")
}

func generateServiceImplementation(g *protogen.GeneratedFile, file *protogen.File, service *protogen.Service) {
	g.P("// Concrete implementation of ", interfaceName(service), ".")
	g.P("public final class ", implementationName(service), ": ", interfaceName(service), " {")
	g.P("\t", "private let client: Connect.ProtocolClientInterface")
	g.P()
	g.P("\t", "public init(client: Connect.ProtocolClientInterface) {")
	g.P("\t\t", "self.client = client")
	g.P("\t", "}")

	for _, method := range service.Methods {
		methodPath := fmt.Sprintf("\"%s/%s\"", service.Desc.FullName(), method.Desc.Name())

		g.P()
		g.P("\t", "public ", methodSignature(method, file, true), " {")
		if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
			g.P("\t\t", "return self.client.bidirectionalStream(path: ", methodPath, ", headers: headers, onResult: onResult)")
		} else if method.Desc.IsStreamingServer() {
			g.P("\t\t", "return self.client.serverOnlyStream(path: ", methodPath, ", headers: headers, onResult: onResult)")
		} else if method.Desc.IsStreamingClient() {
			g.P("\t\t", "return self.client.clientOnlyStream(path: ", methodPath, ", headers: headers, onResult: onResult)")
		} else {
			g.P("\t\t", "self.client.unary(path: ", methodPath, ", request: request, headers: headers, completion: completion)")
		}
		g.P("\t", "}")
	}
	g.P("}")
}

func interfaceName(service *protogen.Service) string {
	return implementationName(service) + "Interface"
}

func implementationName(service *protogen.Service) string {
	return upperCamelCase(service.Desc.Name()) + "Client"
}

func methodSignature(method *protogen.Method, file *protogen.File, includeDefaults bool) string {
	// Default values may only be specified on concrete (non-protocol) types in Swift.
	defaultHeaders := ""
	if includeDefaults {
		defaultHeaders = " = [:]"
	}

	if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
		return "func " +
			lowerCamelCase(method.Desc.Name()) +
			"(headers: Connect.Headers" +
			defaultHeaders +
			", onResult: @escaping (Connect.StreamResult<" +
			swiftFullyQualifiedName(method.Output.Desc.Name(), file) +
			">) -> Void) " +
			"-> any Connect.BidirectionalStreamInterface<" + swiftFullyQualifiedName(method.Input.Desc.Name(), file) + ">"
	} else if method.Desc.IsStreamingServer() {
		return "func " +
			lowerCamelCase(method.Desc.Name()) +
			"(headers: Connect.Headers" +
			defaultHeaders +
			", onResult: @escaping (Connect.StreamResult<" +
			swiftFullyQualifiedName(method.Output.Desc.Name(), file) +
			">) -> Void) " +
			"-> any Connect.ServerOnlyStreamInterface<" + swiftFullyQualifiedName(method.Input.Desc.Name(), file) + ">"
	} else if method.Desc.IsStreamingClient() {
		return "func " +
			lowerCamelCase(method.Desc.Name()) +
			"(headers: Connect.Headers" +
			defaultHeaders +
			", onResult: @escaping (Connect.StreamResult<" +
			swiftFullyQualifiedName(method.Output.Desc.Name(), file) +
			">) -> Void) " +
			"-> any Connect.ClientOnlyStreamInterface<" + swiftFullyQualifiedName(method.Input.Desc.Name(), file) + ">"
	} else {
		return "func " +
			lowerCamelCase(method.Desc.Name()) +
			"(request: " + swiftFullyQualifiedName(method.Input.Desc.Name(), file) +
			", headers: Connect.Headers" +
			defaultHeaders +
			", completion: @escaping (ResponseMessage<" +
			swiftFullyQualifiedName(method.Output.Desc.Name(), file) +
			">) -> Void)"
	}
}

func swiftFullyQualifiedName(name protoreflect.Name, file *protogen.File) string {
	upperCamelName := upperCamelCase(name)
	return upperCamelName
	// TODO: Uncomment after adding support for upper-camel-casing and swift_prefix to Wire, which supports neither
	//if file.Proto.Options.SwiftPrefix != nil {
	//	return fmt.Sprintf("%s%s", *file.Proto.Options.SwiftPrefix, upperCamelName)
	//} else {
	//	upperCamelPackage := upperCamelCase(protoreflect.Name(file.Desc.FullName()))
	//	return fmt.Sprintf("%s_%s", strings.ReplaceAll(upperCamelPackage, ".", "_"), upperCamelName)
	//}
}

func upperCamelCase(name protoreflect.Name) string {
	finalText := ""
	for _, component := range strings.Split(string(name), ".") {
		finalText += fmt.Sprintf("%s%s", strings.ToUpper(string(component[0])), component[1:])
	}
	return finalText
}

func lowerCamelCase(name protoreflect.Name) string {
	finalText := ""
	for index, component := range strings.Split(string(name), ".") {
		if index == 0 {
			finalText += fmt.Sprintf("%s%s", strings.ToLower(string(component[0])), component[1:])
		} else {
			finalText += fmt.Sprintf("%s%s", strings.ToUpper(string(component[0])), component[1:])
		}
	}
	return finalText
}
