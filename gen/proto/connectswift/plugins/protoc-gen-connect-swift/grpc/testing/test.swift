// Code generated by plugin. DO NOT EDIT.
//
// Source: grpc/testing/test.proto

import Connect
import Foundation

// A simple service to test the various types of RPCs and experiment with
// performance with various types of payload.
public protocol TestServiceClientInterface {

	// One empty request followed by one empty response.
	func emptyCall(request: Grpc_Testing_Empty, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void)

	// One request followed by one response.
	func unaryCall(request: Grpc_Testing_SimpleRequest, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_SimpleResponse>) -> Void)

	// One request followed by one response. This RPC always fails.
	func failUnaryCall(request: Grpc_Testing_SimpleRequest, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_SimpleResponse>) -> Void)

	// One request followed by one response. Response has cache control
	// headers set such that a caching HTTP proxy (such as GFE) can
	// satisfy subsequent requests.
	func cacheableUnaryCall(request: Grpc_Testing_SimpleRequest, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_SimpleResponse>) -> Void)

	// One request followed by a sequence of responses (streamed download).
	// The server returns the payload with client desired type and sizes.
	func streamingOutputCall(headers: Connect.Headers, onResult: @escaping (Connect.StreamResult<Grpc_Testing_StreamingOutputCallResponse>) -> Void) -> any Connect.ServerOnlyStreamInterface<Grpc_Testing_StreamingOutputCallRequest>

	// One request followed by a sequence of responses (streamed download). This RPC always fails.
	func failStreamingOutputCall(headers: Connect.Headers, onResult: @escaping (Connect.StreamResult<Grpc_Testing_StreamingOutputCallResponse>) -> Void) -> any Connect.ServerOnlyStreamInterface<Grpc_Testing_StreamingOutputCallRequest>

	// A sequence of requests followed by one response (streamed upload).
	// The server returns the aggregated size of client payload as the result.
	func streamingInputCall(headers: Connect.Headers, onResult: @escaping (Connect.StreamResult<Grpc_Testing_StreamingInputCallResponse>) -> Void) -> any Connect.ClientOnlyStreamInterface<Grpc_Testing_StreamingInputCallRequest>

	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	func fullDuplexCall(headers: Connect.Headers, onResult: @escaping (Connect.StreamResult<Grpc_Testing_StreamingOutputCallResponse>) -> Void) -> any Connect.BidirectionalStreamInterface<Grpc_Testing_StreamingOutputCallRequest>

	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client requests and then serves them in order. A
	// stream of responses are returned to the client when the server starts with
	// first request.
	func halfDuplexCall(headers: Connect.Headers, onResult: @escaping (Connect.StreamResult<Grpc_Testing_StreamingOutputCallResponse>) -> Void) -> any Connect.BidirectionalStreamInterface<Grpc_Testing_StreamingOutputCallRequest>

	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented methods.
	func unimplementedCall(request: Grpc_Testing_Empty, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void)

	// The test server will not implement this method. It will be used
	// to test the behavior when clients call unimplemented streaming output methods.
	func unimplementedStreamingOutputCall(headers: Connect.Headers, onResult: @escaping (Connect.StreamResult<Grpc_Testing_Empty>) -> Void) -> any Connect.ServerOnlyStreamInterface<Grpc_Testing_Empty>
}

// Concrete implementation of TestServiceClientInterface.
public final class TestServiceClient: TestServiceClientInterface {
	private let client: Connect.ProtocolClientInterface

	public init(client: Connect.ProtocolClientInterface) {
		self.client = client
	}

	public func emptyCall(request: Grpc_Testing_Empty, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void) {
		self.client.unary(path: "grpc.testing.TestService/EmptyCall", request: request, headers: headers, completion: completion)
	}

	public func unaryCall(request: Grpc_Testing_SimpleRequest, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_SimpleResponse>) -> Void) {
		self.client.unary(path: "grpc.testing.TestService/UnaryCall", request: request, headers: headers, completion: completion)
	}

	public func failUnaryCall(request: Grpc_Testing_SimpleRequest, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_SimpleResponse>) -> Void) {
		self.client.unary(path: "grpc.testing.TestService/FailUnaryCall", request: request, headers: headers, completion: completion)
	}

	public func cacheableUnaryCall(request: Grpc_Testing_SimpleRequest, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_SimpleResponse>) -> Void) {
		self.client.unary(path: "grpc.testing.TestService/CacheableUnaryCall", request: request, headers: headers, completion: completion)
	}

	public func streamingOutputCall(headers: Connect.Headers = [:], onResult: @escaping (Connect.StreamResult<Grpc_Testing_StreamingOutputCallResponse>) -> Void) -> any Connect.ServerOnlyStreamInterface<Grpc_Testing_StreamingOutputCallRequest> {
		return self.client.serverOnlyStream(path: "grpc.testing.TestService/StreamingOutputCall", headers: headers, onResult: onResult)
	}

	public func failStreamingOutputCall(headers: Connect.Headers = [:], onResult: @escaping (Connect.StreamResult<Grpc_Testing_StreamingOutputCallResponse>) -> Void) -> any Connect.ServerOnlyStreamInterface<Grpc_Testing_StreamingOutputCallRequest> {
		return self.client.serverOnlyStream(path: "grpc.testing.TestService/FailStreamingOutputCall", headers: headers, onResult: onResult)
	}

	public func streamingInputCall(headers: Connect.Headers = [:], onResult: @escaping (Connect.StreamResult<Grpc_Testing_StreamingInputCallResponse>) -> Void) -> any Connect.ClientOnlyStreamInterface<Grpc_Testing_StreamingInputCallRequest> {
		return self.client.clientOnlyStream(path: "grpc.testing.TestService/StreamingInputCall", headers: headers, onResult: onResult)
	}

	public func fullDuplexCall(headers: Connect.Headers = [:], onResult: @escaping (Connect.StreamResult<Grpc_Testing_StreamingOutputCallResponse>) -> Void) -> any Connect.BidirectionalStreamInterface<Grpc_Testing_StreamingOutputCallRequest> {
		return self.client.bidirectionalStream(path: "grpc.testing.TestService/FullDuplexCall", headers: headers, onResult: onResult)
	}

	public func halfDuplexCall(headers: Connect.Headers = [:], onResult: @escaping (Connect.StreamResult<Grpc_Testing_StreamingOutputCallResponse>) -> Void) -> any Connect.BidirectionalStreamInterface<Grpc_Testing_StreamingOutputCallRequest> {
		return self.client.bidirectionalStream(path: "grpc.testing.TestService/HalfDuplexCall", headers: headers, onResult: onResult)
	}

	public func unimplementedCall(request: Grpc_Testing_Empty, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void) {
		self.client.unary(path: "grpc.testing.TestService/UnimplementedCall", request: request, headers: headers, completion: completion)
	}

	public func unimplementedStreamingOutputCall(headers: Connect.Headers = [:], onResult: @escaping (Connect.StreamResult<Grpc_Testing_Empty>) -> Void) -> any Connect.ServerOnlyStreamInterface<Grpc_Testing_Empty> {
		return self.client.serverOnlyStream(path: "grpc.testing.TestService/UnimplementedStreamingOutputCall", headers: headers, onResult: onResult)
	}
}
// A simple service NOT implemented at servers so clients can test for
// that case.
public protocol UnimplementedServiceClientInterface {

	// A call that no server should implement
	func unimplementedCall(request: Grpc_Testing_Empty, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void)

	// A call that no server should implement
	func unimplementedStreamingOutputCall(headers: Connect.Headers, onResult: @escaping (Connect.StreamResult<Grpc_Testing_Empty>) -> Void) -> any Connect.ServerOnlyStreamInterface<Grpc_Testing_Empty>
}

// Concrete implementation of UnimplementedServiceClientInterface.
public final class UnimplementedServiceClient: UnimplementedServiceClientInterface {
	private let client: Connect.ProtocolClientInterface

	public init(client: Connect.ProtocolClientInterface) {
		self.client = client
	}

	public func unimplementedCall(request: Grpc_Testing_Empty, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void) {
		self.client.unary(path: "grpc.testing.UnimplementedService/UnimplementedCall", request: request, headers: headers, completion: completion)
	}

	public func unimplementedStreamingOutputCall(headers: Connect.Headers = [:], onResult: @escaping (Connect.StreamResult<Grpc_Testing_Empty>) -> Void) -> any Connect.ServerOnlyStreamInterface<Grpc_Testing_Empty> {
		return self.client.serverOnlyStream(path: "grpc.testing.UnimplementedService/UnimplementedStreamingOutputCall", headers: headers, onResult: onResult)
	}
}
// A service used to control reconnect server.
public protocol ReconnectServiceClientInterface {

	
	func start(request: Grpc_Testing_ReconnectParams, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void)

	
	func stop(request: Grpc_Testing_Empty, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_ReconnectInfo>) -> Void)
}

// Concrete implementation of ReconnectServiceClientInterface.
public final class ReconnectServiceClient: ReconnectServiceClientInterface {
	private let client: Connect.ProtocolClientInterface

	public init(client: Connect.ProtocolClientInterface) {
		self.client = client
	}

	public func start(request: Grpc_Testing_ReconnectParams, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void) {
		self.client.unary(path: "grpc.testing.ReconnectService/Start", request: request, headers: headers, completion: completion)
	}

	public func stop(request: Grpc_Testing_Empty, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_ReconnectInfo>) -> Void) {
		self.client.unary(path: "grpc.testing.ReconnectService/Stop", request: request, headers: headers, completion: completion)
	}
}
// A service used to obtain stats for verifying LB behavior.
public protocol LoadBalancerStatsServiceClientInterface {

	// Gets the backend distribution for RPCs sent by a test client.
	func getClientStats(request: Grpc_Testing_LoadBalancerStatsRequest, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_LoadBalancerStatsResponse>) -> Void)

	// Gets the accumulated stats for RPCs sent by a test client.
	func getClientAccumulatedStats(request: Grpc_Testing_LoadBalancerAccumulatedStatsRequest, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_LoadBalancerAccumulatedStatsResponse>) -> Void)
}

// Concrete implementation of LoadBalancerStatsServiceClientInterface.
public final class LoadBalancerStatsServiceClient: LoadBalancerStatsServiceClientInterface {
	private let client: Connect.ProtocolClientInterface

	public init(client: Connect.ProtocolClientInterface) {
		self.client = client
	}

	public func getClientStats(request: Grpc_Testing_LoadBalancerStatsRequest, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_LoadBalancerStatsResponse>) -> Void) {
		self.client.unary(path: "grpc.testing.LoadBalancerStatsService/GetClientStats", request: request, headers: headers, completion: completion)
	}

	public func getClientAccumulatedStats(request: Grpc_Testing_LoadBalancerAccumulatedStatsRequest, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_LoadBalancerAccumulatedStatsResponse>) -> Void) {
		self.client.unary(path: "grpc.testing.LoadBalancerStatsService/GetClientAccumulatedStats", request: request, headers: headers, completion: completion)
	}
}
// A service to remotely control health status of an xDS test server.
public protocol XdsUpdateHealthServiceClientInterface {

	
	func setServing(request: Grpc_Testing_Empty, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void)

	
	func setNotServing(request: Grpc_Testing_Empty, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void)
}

// Concrete implementation of XdsUpdateHealthServiceClientInterface.
public final class XdsUpdateHealthServiceClient: XdsUpdateHealthServiceClientInterface {
	private let client: Connect.ProtocolClientInterface

	public init(client: Connect.ProtocolClientInterface) {
		self.client = client
	}

	public func setServing(request: Grpc_Testing_Empty, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void) {
		self.client.unary(path: "grpc.testing.XdsUpdateHealthService/SetServing", request: request, headers: headers, completion: completion)
	}

	public func setNotServing(request: Grpc_Testing_Empty, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_Empty>) -> Void) {
		self.client.unary(path: "grpc.testing.XdsUpdateHealthService/SetNotServing", request: request, headers: headers, completion: completion)
	}
}
// A service to dynamically update the configuration of an xDS test client.
public protocol XdsUpdateClientConfigureServiceClientInterface {

	// Update the tes client's configuration.
	func configure(request: Grpc_Testing_ClientConfigureRequest, headers: Connect.Headers, completion: @escaping (ResponseMessage<Grpc_Testing_ClientConfigureResponse>) -> Void)
}

// Concrete implementation of XdsUpdateClientConfigureServiceClientInterface.
public final class XdsUpdateClientConfigureServiceClient: XdsUpdateClientConfigureServiceClientInterface {
	private let client: Connect.ProtocolClientInterface

	public init(client: Connect.ProtocolClientInterface) {
		self.client = client
	}

	public func configure(request: Grpc_Testing_ClientConfigureRequest, headers: Connect.Headers = [:], completion: @escaping (ResponseMessage<Grpc_Testing_ClientConfigureResponse>) -> Void) {
		self.client.unary(path: "grpc.testing.XdsUpdateClientConfigureService/Configure", request: request, headers: headers, completion: completion)
	}
}
