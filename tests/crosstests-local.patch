diff --git a/cmd/serverconnect/main.go b/cmd/serverconnect/main.go
index de3169f..6b64a43 100644
--- a/cmd/serverconnect/main.go
+++ b/cmd/serverconnect/main.go
@@ -20,6 +20,8 @@ import (
 	"crypto/x509"
 	"errors"
 	"fmt"
+	"github.com/bufbuild/connect-crosstest/internal/gen/proto/connect/grpc/testing/testingconnect"
+	"github.com/bufbuild/connect-crosstest/internal/interop/interopconnect"
 	"log"
 	"net/http"
 	"os"
@@ -27,12 +29,12 @@ import (
 	"syscall"
 	"time"
 
-	"github.com/bufbuild/connect-crosstest/internal/gen/proto/connect/grpc/testing/testingconnect"
 	serverpb "github.com/bufbuild/connect-crosstest/internal/gen/proto/go/server/v1"
-	"github.com/bufbuild/connect-crosstest/internal/interop/interopconnect"
 	"github.com/lucas-clemente/quic-go/http3"
 	"github.com/rs/cors"
 	"github.com/spf13/cobra"
+	"golang.org/x/net/http2"
+	"golang.org/x/net/http2/h2c"
 	"google.golang.org/protobuf/encoding/protojson"
 )
 
@@ -71,9 +73,9 @@ func bind(cmd *cobra.Command, flagset *flags) error {
 	cmd.Flags().StringVar(&flagset.h1Port, h1PortFlagName, "", "port for HTTP/1.1 traffic")
 	cmd.Flags().StringVar(&flagset.h2Port, h2PortFlagName, "", "port for HTTP/2 traffic")
 	cmd.Flags().StringVar(&flagset.h3Port, h3PortFlagName, "", "port for HTTP/3 traffic")
-	cmd.Flags().StringVar(&flagset.certFile, certFlagName, "", "path to the TLS cert file")
-	cmd.Flags().StringVar(&flagset.keyFile, keyFlagName, "", "path to the TLS key file")
-	for _, requiredFlag := range []string{h1PortFlagName, h2PortFlagName, certFlagName, keyFlagName} {
+	//cmd.Flags().StringVar(&flagset.certFile, certFlagName, "", "path to the TLS cert file")
+	//cmd.Flags().StringVar(&flagset.keyFile, keyFlagName, "", "path to the TLS key file")
+	for _, requiredFlag := range []string{h1PortFlagName, h2PortFlagName} {
 		if err := cmd.MarkFlagRequired(requiredFlag); err != nil {
 			return err
 		}
@@ -86,6 +88,9 @@ func run(flags *flags) {
 	mux.Handle(testingconnect.NewTestServiceHandler(
 		interopconnect.NewTestServiceHandler(),
 	))
+	mux.Handle(testingconnect.NewUnimplementedServiceHandler(
+		interopconnect.NewTestServiceHandler(),
+	))
 	corsHandler := cors.New(cors.Options{
 		AllowedMethods: []string{
 			http.MethodHead,
@@ -116,22 +121,19 @@ func run(flags *flags) {
 			"Grpc-Status", "Grpc-Message", "Grpc-Status-Details-Bin", "X-Grpc-Test-Echo-Initial",
 			"Trailer-X-Grpc-Test-Echo-Trailing-Bin"},
 	}).Handler(mux)
-	tlsConfig := newTLSConfig(flags.certFile, flags.keyFile)
 	h1Server := http.Server{
 		Addr:    ":" + flags.h1Port,
 		Handler: corsHandler,
 	}
 	h2Server := http.Server{
-		Addr:      ":" + flags.h2Port,
-		Handler:   mux,
-		TLSConfig: tlsConfig,
+		Addr:    ":" + flags.h2Port,
+		Handler: h2c.NewHandler(mux, &http2.Server{}),
 	}
 	var h3Server http3.Server
 	if flags.h3Port != "" {
 		h3Server = http3.Server{
-			Addr:      ":" + flags.h3Port,
-			Handler:   mux,
-			TLSConfig: tlsConfig,
+			Addr:    ":" + flags.h3Port,
+			Handler: mux,
 		}
 	}
 	protocols := []*serverpb.ProtocolSupport{
@@ -196,18 +198,18 @@ func run(flags *flags) {
 	done := make(chan os.Signal, 1)
 	signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
 	go func() {
-		if err := h1Server.ListenAndServeTLS(flags.certFile, flags.keyFile); err != nil && !errors.Is(err, http.ErrServerClosed) {
+		if err := h1Server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
 			log.Fatalln(err)
 		}
 	}()
 	go func() {
-		if err := h2Server.ListenAndServeTLS(flags.certFile, flags.keyFile); err != nil && !errors.Is(err, http.ErrServerClosed) {
+		if err := h2Server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
 			log.Fatalln(err)
 		}
 	}()
 	if flags.h3Port != "" {
 		go func() {
-			if err := h3Server.ListenAndServeTLS(flags.certFile, flags.keyFile); err != nil && !errors.Is(err, http.ErrServerClosed) {
+			if err := h3Server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
 				log.Fatalln(err)
 			}
 		}()
